{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"InvoiceBldr Last Revision: 5/18/20 Latest Application Release: v1.5.1 The following documentation serves as a technical guide for InvoiceBldr, a fullstack application that allows Admin users to create invoices based on .csv datasets. The application supplies multiple pre-made .csv templates with pre-defined column names. These templates are based on two different overarching use-cases: service , and manufactoring . Invoices are stored in a PostgreSQL database and made accessible to Client user accounts. Clients can view details regarding each invoice, download attachments and supporting documents, leave notes to communicate back to the Admin, and change the status of each invoice from pending to disputed and finally approved . InvoiceBldr integrates Google resources such as Calendar, Sheets, and Mail using OAuth2.0 and the Google Client Library. Google API integration streamlines communication from within the app, and dynamically updates both Admin and Client calendars to reflect invoice due dates. Admins can extract aging reports for all or a subset of their associated Clients. Reports are fully customizable, allowing users to select and filter fields to extract.","title":"Home"},{"location":"#invoicebldr","text":"Last Revision: 5/18/20 Latest Application Release: v1.5.1 The following documentation serves as a technical guide for InvoiceBldr, a fullstack application that allows Admin users to create invoices based on .csv datasets. The application supplies multiple pre-made .csv templates with pre-defined column names. These templates are based on two different overarching use-cases: service , and manufactoring . Invoices are stored in a PostgreSQL database and made accessible to Client user accounts. Clients can view details regarding each invoice, download attachments and supporting documents, leave notes to communicate back to the Admin, and change the status of each invoice from pending to disputed and finally approved . InvoiceBldr integrates Google resources such as Calendar, Sheets, and Mail using OAuth2.0 and the Google Client Library. Google API integration streamlines communication from within the app, and dynamically updates both Admin and Client calendars to reflect invoice due dates. Admins can extract aging reports for all or a subset of their associated Clients. Reports are fully customizable, allowing users to select and filter fields to extract.","title":"InvoiceBldr"},{"location":"release-notes/","text":"Release Notes v1.4.3 This issue contains multiple bug fixes and improved performance stability stability. Bug fixes Fixed an issue that resulted in users being logged out after 5 minutes of inactivity. Fixed an issue that caused inconsistent color rendering when using Night Mode. v1.5.0 Admins now have the ability to extract aging reports for a single client, a group of clients or for all clients. Aging reports can be customized for any given interval of time. This version includes improved performance and stability in generating reports and submitting invoice notes. New Features A new toolbar has been added to the invoice table to allow for filtering clients. The client homepage now displays a bar-graph of the cumulative open balance for a 3-month period. Time-intervals for the bar-graph can be adjusted and customized. Bug fixes Fixed an issue that caused inconsistent delivery of invoice notes","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#v143","text":"This issue contains multiple bug fixes and improved performance stability stability.","title":"v1.4.3"},{"location":"release-notes/#bug-fixes","text":"Fixed an issue that resulted in users being logged out after 5 minutes of inactivity. Fixed an issue that caused inconsistent color rendering when using Night Mode.","title":"Bug fixes"},{"location":"release-notes/#v150","text":"Admins now have the ability to extract aging reports for a single client, a group of clients or for all clients. Aging reports can be customized for any given interval of time. This version includes improved performance and stability in generating reports and submitting invoice notes.","title":"v1.5.0"},{"location":"release-notes/#new-features","text":"A new toolbar has been added to the invoice table to allow for filtering clients. The client homepage now displays a bar-graph of the cumulative open balance for a 3-month period. Time-intervals for the bar-graph can be adjusted and customized.","title":"New Features"},{"location":"release-notes/#bug-fixes_1","text":"Fixed an issue that caused inconsistent delivery of invoice notes","title":"Bug fixes"},{"location":"tech/","text":"Technical Guide Overview InvoiceBldr is created as a cluster of 4 microservices in a loosely coupled architecture. Each microservice is deployed as a containerized unit in an AWS Elastic Beanstalk (EBS) application environment. EBS provides a level of abstraction on top of AWS's Compute servce, EC2 . EBS offers managed platforms for deploying and maintaining web servers, streamlining the instance configuration and maintainance process. The server-side microservices share and maintain a state and progressively update the single-page front-end application using push notifications. The server-side nodes utilize AWS SQS to establish messaging queues, send, recieve, and finally process requests by querying the database. For more information on using SQS, visit the SQS Messaging section of this guide. Server-side Microservices: Invoice Processing Notifications Logs and Reports Frameworks UI Microservice JavaScript Vue JS Vuex Store Vuetify *The client side application is deployed on AWS S3, using S3's static web hosting feature. Server-side Microservices Python 3.7 Flask Getting Started # Server set-up and installation pipenv install # Install dependencies from Pipfile and create a virtual environment pipenv shell # Access the environment shell python app.py # Start the development server # Client set-up and installation npm install # Install dependencies from package.json npm start # Start the development server Note: Flask applications must run within a virtual environment in order to manage dependencies. As a result, certain software and utilities, such as the Google API client, must be installed within the virtual environment. This example demonstrates the steps needed to install the Google API Client Library : # Load the environment's /activate script into the shell source ~/.virtualenvs/name-of-environment/activate # install the module using pip3 python3-pip install -I google-api-python-client A pipenv virtual environment can be removed by using the -rm command: pipenv --rm If the virtual environment is removed, pipenv install and pipenv shell commands are required before the Flask application can be restarted. Interacting with AWS S3 All original invoice documents and supporting attachments are uploaded to an S3 bucket using the AWS Boto3 client and stored in a Glacier Deep Archive . S3 does not recognize a directory hierarchy, and instead identifies each object with a unique key that signifies its absolute path. This example demonstrates how object keys are used to store documents in different sub directories. Uploading an Object import boto3 from dotenv import load_dotenv # the accessKey and secrecKey are defined in the /.env file accessKey = os.getenv('accessKey') secretKey = os.getenv('secretKey') # create the boto3 s3 client service s3_client = boto3.client('s3', aws_access_key_id=accessKey, aws_secret_access_key=secretKey) # the put_object method adds an object to an S3 bucket based on the object-key passed response = s3_client.put_object( ACL= 'public-read', # allows public access to the object Bucket='invoice-docs', # the bucket for storing invoice-related documents Body=body, # the binary file object parsed from the request body Key=f'csv-invoices/{admin_id}/{client_id}/{invoice_number}.csv' # identifies the absolute path of the object, including any subdirectories ) print(response) The example above creates a subdirectory for the unique admin_id , and another nested subdirectory for each client_id . The upload object can subsequently be retrieved by passing the entire key as its absolute path. Subdirectories and objects are created only if they do not currently exist within the bucket. If an object is updated, a new version of the object is saved in the S3 bucket Note: The keys for invoice file objects and subdirectories must be created using this naming convention in order to allow for unifrom accessibility across the application. Downloading an Object the get_object method accepts (Bucket='name-of-bucket', Key='object-key') as arguments. Here, Key refers the object's full key, including any nested subdirectories. import boto3 accessKey = os.getenv('accessKey') secretKey = os.getenv('secretKey') s3_client = boto3.client('s3', aws_access_key_id=accessKey, aws_secret_access_key=secretKey) # Call the get_object method and save the response in a variable response = s3_client.get_object(Bucket='invoice-docs', Key=f'{admin_id}/{client_id}/{invoice_number}.csv') print(response) Messaging with AWS SQS Overview AWS SQS provides secure messaging queues that allow integration between decoupled or loosely coupled software systems. SQS plays an essential role in implementing InvoiceBldr as a collection of microservices in a decoupled design architecture. While SQS allows for both standard and FIFO queue configurations, InvoiceBldr uses a standard configuration for communication between services. Doing so allows the application microservices to utilize the At Least Once Delivery feature. At Least Once Delivery ensures communication reliability between decoupled services. If a message fails or is rejected by the reciever, it can be re-captured by the SQS queue, processed, and then re-sent. Example This example demonstrates using the sendMessage method from the SQS Javascript SDK to create and save an invoice note. /* the message body will include the admin userId and the client userId, the invoice number, and the text of the note */ const body = { adminId: '12345', clientId: '67890', invoiceNumber: '13579' body: 'This is a sample note.' } /* create an SQS client using the AWS SDK */ const sqs = new AWS.SQS ( { endpoint: 'sqs.us-west-2.amazonaws.com' accessKeyId: 'AWS_ACCESS_KEY', secretAccessKey: 'AWS_SECRET_KEY' } ); const params = { MessageBody: body, /* SQS accepts JSON, XML and plain text as MessageBody */ QueueUrl: '/123456789012/InvoiceNotes', }; sqs.sendMessage(params, (err, data) => { if (err) { console.log(err, err.stack) } else { console.log(data) } }); The following example demonstrates using the recieve_message method of the SQS Javascript SDK to recieve a message form a target queue. const sqs = new AWS.SQS ( { endpoint: 'sqs.us-west-2.amazonaws.com' accessKeyId: 'AWS_ACCESS_KEY', secretAccessKey: 'AWS_SECRET_KEY' } ); response = sqs.receive_message( QueueUrl='/123456789012/InvoiceNotes', AttributeNames=['All'], ) console.log(response)","title":"Technical Guide"},{"location":"tech/#technical-guide","text":"","title":"Technical Guide"},{"location":"tech/#overview","text":"InvoiceBldr is created as a cluster of 4 microservices in a loosely coupled architecture. Each microservice is deployed as a containerized unit in an AWS Elastic Beanstalk (EBS) application environment. EBS provides a level of abstraction on top of AWS's Compute servce, EC2 . EBS offers managed platforms for deploying and maintaining web servers, streamlining the instance configuration and maintainance process. The server-side microservices share and maintain a state and progressively update the single-page front-end application using push notifications. The server-side nodes utilize AWS SQS to establish messaging queues, send, recieve, and finally process requests by querying the database. For more information on using SQS, visit the SQS Messaging section of this guide. Server-side Microservices: Invoice Processing Notifications Logs and Reports","title":"Overview"},{"location":"tech/#frameworks","text":"UI Microservice JavaScript Vue JS Vuex Store Vuetify *The client side application is deployed on AWS S3, using S3's static web hosting feature. Server-side Microservices Python 3.7 Flask","title":"Frameworks"},{"location":"tech/#getting-started","text":"# Server set-up and installation pipenv install # Install dependencies from Pipfile and create a virtual environment pipenv shell # Access the environment shell python app.py # Start the development server # Client set-up and installation npm install # Install dependencies from package.json npm start # Start the development server Note: Flask applications must run within a virtual environment in order to manage dependencies. As a result, certain software and utilities, such as the Google API client, must be installed within the virtual environment. This example demonstrates the steps needed to install the Google API Client Library : # Load the environment's /activate script into the shell source ~/.virtualenvs/name-of-environment/activate # install the module using pip3 python3-pip install -I google-api-python-client A pipenv virtual environment can be removed by using the -rm command: pipenv --rm If the virtual environment is removed, pipenv install and pipenv shell commands are required before the Flask application can be restarted.","title":"Getting Started"},{"location":"tech/#interacting-with-aws-s3","text":"All original invoice documents and supporting attachments are uploaded to an S3 bucket using the AWS Boto3 client and stored in a Glacier Deep Archive . S3 does not recognize a directory hierarchy, and instead identifies each object with a unique key that signifies its absolute path. This example demonstrates how object keys are used to store documents in different sub directories.","title":"Interacting with AWS S3"},{"location":"tech/#uploading-an-object","text":"import boto3 from dotenv import load_dotenv # the accessKey and secrecKey are defined in the /.env file accessKey = os.getenv('accessKey') secretKey = os.getenv('secretKey') # create the boto3 s3 client service s3_client = boto3.client('s3', aws_access_key_id=accessKey, aws_secret_access_key=secretKey) # the put_object method adds an object to an S3 bucket based on the object-key passed response = s3_client.put_object( ACL= 'public-read', # allows public access to the object Bucket='invoice-docs', # the bucket for storing invoice-related documents Body=body, # the binary file object parsed from the request body Key=f'csv-invoices/{admin_id}/{client_id}/{invoice_number}.csv' # identifies the absolute path of the object, including any subdirectories ) print(response) The example above creates a subdirectory for the unique admin_id , and another nested subdirectory for each client_id . The upload object can subsequently be retrieved by passing the entire key as its absolute path. Subdirectories and objects are created only if they do not currently exist within the bucket. If an object is updated, a new version of the object is saved in the S3 bucket Note: The keys for invoice file objects and subdirectories must be created using this naming convention in order to allow for unifrom accessibility across the application.","title":"Uploading an Object"},{"location":"tech/#downloading-an-object","text":"the get_object method accepts (Bucket='name-of-bucket', Key='object-key') as arguments. Here, Key refers the object's full key, including any nested subdirectories. import boto3 accessKey = os.getenv('accessKey') secretKey = os.getenv('secretKey') s3_client = boto3.client('s3', aws_access_key_id=accessKey, aws_secret_access_key=secretKey) # Call the get_object method and save the response in a variable response = s3_client.get_object(Bucket='invoice-docs', Key=f'{admin_id}/{client_id}/{invoice_number}.csv') print(response)","title":"Downloading an Object"},{"location":"tech/#messaging-with-aws-sqs","text":"","title":"Messaging with AWS SQS"},{"location":"tech/#overview_1","text":"AWS SQS provides secure messaging queues that allow integration between decoupled or loosely coupled software systems. SQS plays an essential role in implementing InvoiceBldr as a collection of microservices in a decoupled design architecture. While SQS allows for both standard and FIFO queue configurations, InvoiceBldr uses a standard configuration for communication between services. Doing so allows the application microservices to utilize the At Least Once Delivery feature. At Least Once Delivery ensures communication reliability between decoupled services. If a message fails or is rejected by the reciever, it can be re-captured by the SQS queue, processed, and then re-sent.","title":"Overview"},{"location":"tech/#example","text":"This example demonstrates using the sendMessage method from the SQS Javascript SDK to create and save an invoice note. /* the message body will include the admin userId and the client userId, the invoice number, and the text of the note */ const body = { adminId: '12345', clientId: '67890', invoiceNumber: '13579' body: 'This is a sample note.' } /* create an SQS client using the AWS SDK */ const sqs = new AWS.SQS ( { endpoint: 'sqs.us-west-2.amazonaws.com' accessKeyId: 'AWS_ACCESS_KEY', secretAccessKey: 'AWS_SECRET_KEY' } ); const params = { MessageBody: body, /* SQS accepts JSON, XML and plain text as MessageBody */ QueueUrl: '/123456789012/InvoiceNotes', }; sqs.sendMessage(params, (err, data) => { if (err) { console.log(err, err.stack) } else { console.log(data) } }); The following example demonstrates using the recieve_message method of the SQS Javascript SDK to recieve a message form a target queue. const sqs = new AWS.SQS ( { endpoint: 'sqs.us-west-2.amazonaws.com' accessKeyId: 'AWS_ACCESS_KEY', secretAccessKey: 'AWS_SECRET_KEY' } ); response = sqs.receive_message( QueueUrl='/123456789012/InvoiceNotes', AttributeNames=['All'], ) console.log(response)","title":"Example"}]}